      1  方法签名(方法的识别关键字)
	   方法签名 = 方法名+参数类型列表
	   Java 类中不能存在相同方法签名的方法
	   
	   方法重载: 方法名一样, 方法签名不同的方法
	   
	   char[] chs = {'A','B','C'};
	   int[] ary = {'A','B','C'};
	   System.out.println(chs);//ABC// println(char[])
	   System.out.println(ary);//[[@34ADCD//println(Object)
	   System.out.println(ary.toString());// [[@34ADCD
	   System.out.println('A');//A // println(char) 打印字符
	   System.out.println(65);//65// println(int) 打印整数
	                               打人
	                               打牌
	   方法重载就是: 动词的多意现象, 打人, 打牌, 打酱油, 打车
	   
	   洗衣服, 洗手, 洗照片
	   
	   保存联系人, 保存通话记录, 保存访问过的地址
	   save(Contact) save(Log) save(Url)
	    
	
	2 java方法参数的传递规则: 基于值的传递, 是变量值的复制, 
	     
	      1) 基本类型就是其中值的复制, 
	      2) 引用类型是引用值(地址)的复制.
	         案例: ParameterDemo.java
	         * 变量的值: a 基本类型的值是其本身,
	                     b 引用变量的值是一个地址值,是被引用对象的首地址.
	         为了避免引用参数传递的副作用, 建议一切结果使用返回值带回. 
	
	3 继承 用来表达概念上具体化延续的具体概念.
	      
	       1 * 子类继承父类的属性和方法
	       2 * 构造器不能继承！
	       3 实例化子类，会递归分配所有父类的空间
	       4 子类构造器一定调用父类构造器
	 
	       * 类一定有构造器
	
	4 关于继承中的构造器：
	         1 * 子类构造器中, 一定调用父类构造器。
	         2 子类构造器 默认调用父类无参数构造器！
	         3 如果父类没有无参数构造器，就必须在子类中明确指定调用 父类的有参数构造器！
	         4 使用super()调用父类构造器，必须写在子类构造器第一行this() 必须写在子类构造器第一行
	         5 编程建议：所有的类都提供无参数构造器！减少继承时候的麻烦。
	 
	5 关于对象的实例化过程：
	     1 检查类是否加载，如果没有加载就加载这个类，要加载所有父类。
	       * 懒惰式加载（按需加载）：如果第一次用到就加载，
	       只加载一次。通过CLASSPATH指定的路径寻找类文件(.class)，
	       加载以后是一个对象，类型是Class。
	       获得这个类对象：Student.class-> Class 实例
	     2 在内存堆中分配对象空间。递归分配所有父类和子类属性空间。
	       属性默认自动初始化。自动初始化为“0”值。
	     3 进行属性的赋值。
	     4 递归调用父类构造器。(默认调用父类无参数构造器！)
	     5 调用本类构造器。
	
	6 访问控制修饰符
	     1 public   类内 包内 子类 任意
	     2 protected  类内 包内 子类 
	     3 default 很少使用，很少使用package作为访问控制的边界  类内 包内
	     4 private   类内
	 
	 * 一般自然现象: 都是尽可能的封装典型.
	 
	 声明属性和方法尽可能私有。这样才能做到尽可能的封装。
	 提供适当的属性访问方法，适当的开放属性的访问。
	 
	 一个源文件可以有多个类, 但是只能有一个public类, 
	 文件名要与Public类一致. 如果有其他类, 就只能是默认修饰
	 
	 不建议使用非公有类。就是说所有类都应该是公有的，并且
	 一个源文件一个类。
	
	7 继承中的语法现象
	 1 父类型变量可以引用子类型的实例，父类型的实现是多态的！
	 2 子类可以覆盖父类的方法，修改父类的行为。
	   * 方法覆盖：子类覆盖了父类“相同方法签名”的方法。
	   方法的覆盖是由方法动态绑定实现的，就是Java虚拟机运行
	   时候确定执行那个那个对象那个方法，java最终执行子类的方法。
	 
	8 引用类型转换（是引用变量的类型的转换！）
	 1 向下转型（隐式/自动类型转换），是小类型到大类型的转换
	   如：
	   Circle c = new Circle(1,2,3);
	   Shape s = (Shape) c;//表示圆一定是图形
	 
	 2 向上造型（强制类型转换），是大类型到小类型。
	   如：
	   Shape s = (Shape) new Circle(1,2,3);
	   Cirlcle c = (Circle)s; //当s实际引用圆时候，能够转换成功
	   s = new Rectangle(1,1,2,2);
	   Circle c2 = (Circle) s;//出现类型转换异常，因为
	   // s引用的是Rectangle 不是圆实例。
	 3 instanceof 运算符，用来检查引用对象的类型。
	   经常与“引用类型强制转换”配合，实现安全的类型转换，
	   避免类型转换异常。